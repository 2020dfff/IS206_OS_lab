## 操作系统实验2：CFS代码分析

[toc]

## 一、实验题目

​		根据提供的源代码分析CFS的代码实现原理，比如包括哪些函数？设置了哪些关键参数？执行流程是怎样的？结合教材ppt撰写代码分析报告。



## 二、实验目的

1. 加深对CFS (Completely Fair Scheduling) 调度的理解。
2. 对Linux和OpenEuler的底层实现进行分析并掌握。  



## 三、背景知识

### 基本介绍

- cfs定义了一种新的模型，它给cfs_rq（cfs的run queue）中的每一个进程安排一个虚拟时钟: virtual runtime (vruntime)。

- 如果一个进程得以执行，随着时间的增长（也就是一个个tick的到来），其vruntime将不断增大。没有得到执行的进程vruntime不变。
- 而调度器总是选择vruntime跑得最慢的那个进程来执行。这就是所谓的“完全公平”。
- 为了区别不同优先级的进程，优先级高的进程vruntime增长得慢，以至于它可能得到更多的运行机会。

### 设计思路

​		CFS思路很简单，就是根据各个进程的权重分配运行时间：

​		进程的运行时间计算公式为:

> *分配给进程的运行时间 = 调度周期* 进程权重 / 所有进程权重之和

​		调度周期很好理解，就是将所有处于TASK_RUNNING态进程都调度一遍的时间,差不多相当于O(1)调度算法中运行队列和过期队列切换一次的时间。

​		从实际运行时间到vruntime的换算公式：

> vruntime = 实际运行时间 * 1024 (NICE_0_LOAD) / 进程权重

​		这里直接写为1024，实际上它等于nice为0的进程的权重，代码中是NICE_0_LOAD。也就是说，所有进程都以nice为0的进程的权重1024作为基准，计算自己的vruntime增加速度。

​		举个例子，比如只有两个进程A, B，权重分别为1和2，调度周期设为30ms，那么分配给A的CPU时间为:30ms * (1/(1+2)) = 10ms；而B的CPU时间为：30ms * (2/(1+2)) = 20ms。那么在这30ms中A将运行10ms，B将运行20ms。而由于B的权重是A的2倍，那么B的vruntime增加速度只有A的一半。

综合上述两个公式可以知道：

> vruntime = (调度周期 * 进程权重 / 所有进程总权重) * 1024 / 进程权重 = 调度周期 * 1024 / 所有进程总权重

